## Lab: Detecting Hot Spots

>Note: for developers only

**Exercise directory**:  `~/class/exercises/` or use the RowKeys project in Eclipse

**HBase tables**:        `ratingsbymovie`

In this exercise you will work with inserting time series data, learn how to recognize RegionServer hot spots and how different row key types affect hotspotting.

----

### Time Series Data

When dealing with stream processing of events, the most common use-case is `_time_ _series_ data`. This data might be generated by a sensor in a power grid, might represent stock ticks from a stock exchange, or it might represent the year a movie was released. Common in each case is that the data represents the event time.

Time data can pose a problem because of the way HBase arranges rows. Namely, rows are stored sorted in partitions defined for a distinct range. We refer to these partitions as regions. A region is assigned a range and stores row keys that belong to that range. The region range is defined by start key (inclusive) and stop key (exclusive).

The sequential, monotonically increasing nature of time series data causes all incoming data to be written to the same region. Since a single RegionServer hosts this region, all updates will be handled by a single machine, rather than spreading work across the cluster. This can cause regions to run ‘hot’, slowing down the perceived overall performance of the cluster. With monotonically increasing row keys, the speed of data insertion rests with a single machine.

In this exercise, you will run a program that adds the ratings for movies across all users that rated it. The program can create the four different row key types. You will run the exercise and observe the hotspotting characteristics of each row key type.

The program outputs write counters for the number of times a Put was performed on a region. In the first column, it shows the start key for the region. The second column shows the aggregate or total number of writes that region has handled. The final column shows the number of new writes since the last time the program output the statistics.

Each run of the program will recreate the table in HBase. Based on the row key type, a different pre-splitting of the HBase table is used. You can view the splits for each row key type by looking at the RowKeyType enum.

In Eclipse, open the RowKeys project and verify that the rowKeyType variable in the ImportRatingsByMovie class is as follows:

    ```console
    public static RowKeyType rowKeyType =  RowKeyType.SEQUENTIAL;
    ```
    
Run the program and observe the output. Look back at the output while the program was running to see how evenly the load is distributed on the regions. Look at the final distribution of rows in each region to see if they are evenly distributed.

    The time series output row key starts with the year and hot spots because the data set has the greatest number of movies from the 1990's.

Open the hbase shell and type:

    ```console
    hbase> scan 'ratingsbymovie', {LIMIT => 1}
    ```
    
    Look at how the row key is a composite key, and examine the information in the row key.

In Eclipse, change the rowKeyType variable in the `ImportRatingsByMovie` class to:

    ```console
    public static RowKeyType rowKeyType = RowKeyType.SALTED;
    ```
    
Run the program and observe the output. Look back at the output while the program was running to see how even the load is distributed on the regions. Look at the final distribution of rows in each region to see if it is even.

    The time series output will be salted with one random digit. The hotspotting will be minimal but will have problems once the number of regions grows beyond 10 regions.

In the HBase shell, type:

    ```console
    hbase> scan 'ratingsbymovie', {LIMIT => 1}
    ```
    
Look at how the row key is a composite key, note the information in the row key.

In Eclipse, change the rowKeyType variable in the ImportRatingsByMovie class to:

    ```console
    public static RowKeyType rowKeyType =  RowKeyType.PROMOTED;
    ```
    
Run the program and observe the output. Look back at the output while the program was running to see how even the load is distributed on the regions. Look at the final distribution of rows in each region to see if it is even.

The time series field will have the movie name promoted in front of it. There will be hotspotting because the letters of the alphabet in movie names are not uniformly distributed.

In the HBase shell, type:

    ```console
    hbase> scan 'ratingsbymovie', {LIMIT => 1}
    ```
    
Look at how the row key is a composite key; note the information in the row key.

In Eclipse, change the rowKeyType variable in the ImportRatingsByMovie class to:

    ```console
    public static RowKeyType rowKeyType = RowKeyType.RANDOM;
    ```
    
Run the program and observe the output. Look back at the output while the program was running to see how even the load is distributed on the regions. Look at the final distribution of rows in each region to see if it is even.

The time series field will be completely changed by the MD5 hash. MD5 runs a hashing function on the row key, which gives a pseudorandom output. There will be little hotspotting because the data is hashed.

In the HBase shell, type:

    ```console
    hbase> scan 'ratingsbymovie', {LIMIT => 1}
    ```
    
Observe that the row key is an MD5 hash.

### Improving the Salted and Promoted Row Keys

Review the table splits for each row key type in the RowKeyType

Review the `getRowKey` method where the row keys are created based on the year, genre, and movie name.

Try to improve the hotspotting in the salted and promoted keys by changing the algorithm or the way the tables are split. Remember that you may need to adjust the table splits if you change the type or order of the fields in the composite row keys

Run the program again with that `rowKeyType` set to the one that you have just changed and see if there was an improvement in hotspotting.
